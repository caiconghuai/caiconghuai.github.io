<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java," />





  <link rel="alternate" href="/atom.xml" title="蔡聪怀" type="application/atom+xml" />






<meta name="description" content="并发基础CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。    CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下一次切换回这个任务时，可以再加载这个任务的状态。  上下文切换需要时间和开销。 减少">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程总结">
<meta property="og:url" content="http://conghuai.me/2017/06/20/Java多线程总结/index.html">
<meta property="og:site_name" content="蔡聪怀">
<meta property="og:description" content="并发基础CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。    CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下一次切换回这个任务时，可以再加载这个任务的状态。  上下文切换需要时间和开销。 减少">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://p6sh0jwf6.bkt.clouddn.com/2018-04-14-162034.jpg">
<meta property="og:image" content="http://p6sh0jwf6.bkt.clouddn.com/2018-04-17-160954.jpg">
<meta property="og:updated_time" content="2018-04-17T16:10:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程总结">
<meta name="twitter:description" content="并发基础CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。    CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下一次切换回这个任务时，可以再加载这个任务的状态。  上下文切换需要时间和开销。 减少">
<meta name="twitter:image" content="http://p6sh0jwf6.bkt.clouddn.com/2018-04-14-162034.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://conghuai.me/2017/06/20/Java多线程总结/"/>





  <title>Java多线程总结 | 蔡聪怀</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蔡聪怀</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://conghuai.me/2017/06/20/Java多线程总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Conghuai Cai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蔡聪怀">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java多线程总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-20T23:26:49+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software-Engineer/" itemprop="url" rel="index">
                    <span itemprop="name">Software Engineer</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software-Engineer/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Software-Engineer/Java/Concurrency/" itemprop="url" rel="index">
                    <span itemprop="name">Concurrency</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/20/Java多线程总结/" class="leancloud_visitors" data-flag-title="Java多线程总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7,743 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  27 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><p>CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。    CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下一次切换回这个任务时，可以再加载这个任务的状态。</p>
<ul>
<li>上下文切换需要时间和开销。</li>
<li>减少上下文切换的方法：无锁并发编程、CAS算法、使用最少线程和使用协程。</li>
</ul>
<h2 id="三个重要概念"><a href="#三个重要概念" class="headerlink" title="三个重要概念"></a>三个重要概念</h2><ul>
<li><strong>原子性</strong>：一个操作或者多个操作，要么都成功；要么都失败，中间不能由于任何的因素取消。</li>
<li><strong>可见性</strong>：一个线程对共享变量值的修改，能够及时地被其他线程看到。<ul>
<li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是几个线程的共享变量。 </li>
</ul>
</li>
<li><strong>有序性</strong><ul>
<li>代码的执行顺序，编写在前面的发生在编写在后面的</li>
<li>unlock必须发生在lock之后</li>
<li>volatile修饰的变量，对变量的写操作先于该变量的读操作</li>
<li>传递规则，操作A先于B，B先于C，那么A肯定先于C</li>
<li>线程启动规则，start方法肯定先于线程run</li>
<li>线程中断规则，interrupt这个动作，必须发生在捕获该动作之前</li>
<li>对象销毁规则，初始化必须发生在finalize之前</li>
<li>线程终结规则，所有的操作都发生在线程死亡之前</li>
</ul>
</li>
</ul>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul>
<li>安全性的含义是，永远不发生糟糕的事情，当多个线程访问某个类时，这个类始终都能表现出正确的行为。</li>
<li>核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。对象的状态指存储在状态变量中的数据。</li>
<li>修复多个线程访问同一个可变的状态变量，不使用同步的方法：<ul>
<li>不在线程之间共享该状态变量</li>
<li>将状态遍历修改为不可变的变量</li>
</ul>
</li>
</ul>
<h3 id="无状态性"><a href="#无状态性" class="headerlink" title="无状态性"></a>无状态性</h3><ul>
<li>不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。多个线程之间没有共享状态。</li>
<li>无状态对象一定是线程安全的。</li>
</ul>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><ul>
<li>由于多线程共享相同的内存地址空间，并且是并发运行的，因此它们可能会访问或修改其他线程正在使用的变量。</li>
<li>当某个计算正确性取决于多个线程的交替执行时序时，就会发生竟态条件。观察结果的失效性是大多数竟态条件的本质：<strong>基于一种可能失效的观察结果来做出判断或者执行某个计算</strong>。</li>
<li>常见的竟态条件<ul>
<li><strong>先检查后执行</strong>：延迟初始化</li>
</ul>
</li>
</ul>
<h1 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul>
<li><p>Thread是线程对象，用来创建和开始一个线程。</p>
</li>
<li><p>Thread().start()方法用来启动线程，里面会执行Runnable对象的run()方法，这是采用的是策略设计模式。</p>
</li>
<li><p>start0()是native方法，用c++写的，与底层交互。</p>
</li>
<li><p>Thread的命名规则：创建线程对象，默认有一个线程名，从Thread-0开始一次加1。</p>
</li>
<li><p>如果在构造Thread的时候，没有传递Runnable或者没有复写，则该方法不会调用任何东西。</p>
</li>
<li><p>如果构造线程对象时，未传入ThreadGroup，此时会用父线程的ThreadGroup。</p>
</li>
<li><p>构造Thread的时候传入stacksize代表着该线程占用的stack大小，如果没有指定stacksize的大小，默认是0, 0代表着会忽略该参数，该参数会被JNI函数去使用。注意：该参数在一些平台有效，在一些平台无效。</p>
</li>
<li><p>可以通过ThreadFactory的工厂类来创建线程对象。</p>
</li>
<li><p>| name         |<br>| ———— |<br>| priority     |<br>| group        |<br>| tid          |<br>| threadStatus |</p>
</li>
</ul>
<h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>Runnable是给线程执行的对象，必须重写run方法，该方法供对象调用。</p>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><ul>
<li><strong>volatile</strong>：Java编程语言允许线程访问共享变量，为了确保变量能够准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。将当前处理器缓存行的数据写回到系统内存。<strong>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</strong>。<ul>
<li>volatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回<strong>最新</strong>写入的值。</li>
<li>在访问volatile变量时不会执行加锁操作，但是我们可以把它的行为想成加锁的get和set方法。</li>
<li><strong>加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性</strong>。</li>
<li>使用条件：<ul>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ul>
</li>
<li>典型用法：<ul>
<li>检查某个状态标记以判断是否退出循环。</li>
</ul>
</li>
</ul>
</li>
<li>CPU引入cache解决了速度问题，但是又引入了缓存不一致的问题。当CPU在操作的时候，会先在缓存中进行操作，然后将缓存中的内容刷新到CPU中。<br>​          <strong>main memory -&gt; cache （进行操作 如 i++）-&gt; cache -&gt; main memory</strong><br>​          <strong>main memory -&gt; cache （进行操作如 i++）-&gt; cache -&gt; main memory</strong></li>
</ul>
<ul>
<li>解决缓存不一致的方法如下：</li>
<li><ul>
<li>给数据总线加锁：当第一个线程访问主内存的时候就对这块内存区域加锁，在线程操作完并写回主内存之前，其他的线程都不可以读取这块主内存的内容。（效率低下）</li>
<li>CPU高速缓存一致性协议：Intel MESI，核心思想如下：</li>
<li><ul>
<li>当cpu写入数据的时候，如果发现该变量被共享（也就是说，在其他cpu也存在该变量的副本），会发出一个信号，通知其他cpu该变量的缓存无效。</li>
<li>当其他线程访问该变量，重新到内存中读取该变量。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>结合Java内存模型分析图如下:</p>
<p><img src="http://p6sh0jwf6.bkt.clouddn.com/2018-04-14-162034.jpg" alt=""></p>
<p>volatile关键字可以理解为就是缓存一致性协议。保证各个线程中的缓存内容是一致的。</p>
<h2 id="Wait-Set"><a href="#Wait-Set" class="headerlink" title="Wait Set"></a>Wait Set</h2><ul>
<li>如果某个线程调用<strong>LOCK.wait()</strong>，那么该线程会把自己放到<strong>该锁</strong>的wait set中。 </li>
<li>每一个对象都会有一个wait set，用来存放调用了该对象wait方法之后进入block状态线程</li>
<li>wait set 本身是一个抽象的概念，具体的实现方式交给不同的JVM去实现。</li>
<li>线程被notify之后，不一定立即得到执行，线程从wait set中被唤醒顺序不一定是FIFO。</li>
<li>线程从wait set中被唤醒后<strong>还需要去竞争LOCK</strong> ，但是抢完锁之后，会直接从<strong>地址恢复后</strong>的位置继续向下执行。</li>
</ul>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><ul>
<li>对于费时的任务，我们不希望当前线程等待着任务执行结束才做其他事情，我们希望当前线程可以继续执行后面的操作，我们通过Future对象这个凭证来告知之前任务的情况。（实际上，我们会另开一个线程来执行任务）。</li>
<li>这种模式中的角色：<ul>
<li>Future: 代表的是未来的一个凭据</li>
<li>FutureTask: 将你的调用逻辑进行隔离</li>
<li>FutureService: 桥接 Future和 FutureTask</li>
</ul>
</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写分离，提高效率；</p>
<ol>
<li>read read 并行化</li>
<li>read write 不允许</li>
<li>write write 不允许</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">READ</th>
<th style="text-align:center">WRITE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>READ</strong></td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center"><strong>WRITE</strong></td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p>不可变对象一定是线程安全的，可变对象不一定是不安全的。</p>
<ul>
<li>属性定义为private final</li>
<li>不提供任何改变这个变量的方法</li>
<li>不让子类继承，即类定义为final</li>
</ul>
<p>在JDK中有哪些是不可变的对象呢？</p>
<ul>
<li>String</li>
</ul>
<p>谈到了String，我们来讲一讲String，StringBuffer和StringBuilder的区别：</p>
<ol>
<li>三者中，只有String是不可变的，StringBuffer和StringBuilder都是可变的。</li>
<li>三者中，String和StringBuffer都是线程安全的，StringBuilder不是线程安全的。前两者保证线程安全的方式不一样，其中String是通过不可变对象来保证的，而StringBuffer是通过synchronized关键字进行加锁保证的，所以，StringBuffer效率比较低。</li>
</ol>
<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2><ul>
<li>仅在单线程内访问数据，不共享数据。</li>
<li>栈封闭是线程封闭的一种特例，局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。</li>
<li>维持线程封闭性的一种更规范方法是使用<strong>ThreadLocal</strong>, 这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本， 因此get总是返回由当前执行线程在调用set时设置的最新值。<ul>
<li>当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。</li>
<li>从概念上来讲，可以将<code>ThreadLocal&lt;T&gt;</code>视为包含了<code>Map&lt;Thread,T&gt;</code>对象，其中保存了特定于该线程的值。</li>
<li>ThreadLocalRandom是线程本地变量，每个生成随机数的线程都有一个不同的生成器。但都在同一个类中被管理，对于程序员来说时透明的。</li>
<li>相比于使用共享的Random对象为所有线程生成随机数，这种机制具有更好的性能。</li>
</ul>
</li>
</ul>
<h1 id="原子操作、原子变量"><a href="#原子操作、原子变量" class="headerlink" title="原子操作、原子变量"></a>原子操作、原子变量</h1><p>原子操作是指，对于访问同一个状态的所有操作来说，这个操作是一个以原子方式执行的操作。</p>
<p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
<p>每个Java对象都可以被用做一个实现同步的锁，这些锁被称为内置锁或监视锁。线程在进入同步代码块之前会自动获得锁，并且在退出后自动释放锁。</p>
<p>Java的内置锁相当于一个互斥体，这意味着最多只有一个线程能持有这种锁。这个锁保护的同步代码块会以原子方式执行。</p>
<p>每个共享的和可变的变量都应该只由一个锁来保护。</p>
<p>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。</p>
<p>在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，是为了确保某个线程写入该变量的值对于其他线程来说是可见的。</p>
<p>加锁的含义不仅仅局限于互斥行为，还包括<strong>内存可见性</strong>，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p><strong>Synchronized</strong>：使得共享资源在多个线程之间访问时采用了同步的方式，避免线程之间的安全问题。</p>
<ul>
<li>直接使用synchronized给对象和方法加锁，默认使用的<strong>this</strong>这把锁。同一时刻只有一个执行线程被允许访问，其他线程如果试图访问这个对象的其他方法，都会被挂起。</li>
<li>如果给静态的方法加锁，那么此时使用的是类名.class 这把锁。对静态方法加锁，同时只能够被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。</li>
<li>Java中的每一个对象都可以作为锁。<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是synchonized括号里配置的对象。</li>
</ul>
</li>
</ul>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock是一种比synchonized关键字更强大也更灵活的机制。</p>
<ul>
<li>支持更灵活的同步代码块结构。</li>
<li>提供<strong>tryLock()</strong>方法的实现。这个方法试图获取锁，如果锁已被其他线程获取，他将返回false并继续往下执行代码。</li>
<li><strong>Lock</strong>允许分离读和写操作，允许多个读线程和一个写线程。</li>
<li><strong>Condition：</strong><ul>
<li>一个锁可能关联一个或者多个条件，这些条件通过<strong>Condition</strong>接口声明，目的是允许线程获取锁并且查看等待的某一个条件是否满足。如果不满足就挂起直到某个线程唤醒它们。</li>
<li>与锁绑定的所有条件对象都是通过<strong>Lock</strong>接口声明的<strong>newCondition</strong>()方法创建的，在使用条件的时候，必须获取这个条件绑定的锁。所以带条件的代码必须在调用Lock对象的lock()和unlock()方法之间。</li>
<li>当线程调用条件<strong>await</strong>()方法时，它将自动释放这个条件绑定的锁，其他某个线程才可以获取这个锁并且执行相同的操作，或者执行这个锁保护的另一个临界区代码。</li>
<li><strong>awaitUninterruptibly</strong>()是不可中断的，这个线程将休眠直到其他某个线程调用了将它挂起的条件的<strong>signal</strong>()或<strong>signalAll</strong>()方法。</li>
</ul>
</li>
</ul>
<h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><ul>
<li>它能保证<strong>可见性</strong>、<strong>有序性</strong>、<strong>原子性</strong>。</li>
<li>原子变量是从Java5开始引入的，它提供了单个变量上的原子操作。</li>
<li>一般来说，这种操作先获取变量值，然后在本地改变变量的值，然后试图用这个改变的值去替换之前的值。如果之前的值没有被其他线程改变，就可以执行这个替换操作。否则，方法将再执行这个操作。这种操作称为<strong>CAS</strong>原子操作。</li>
<li>采用比较和交换机制不需要使用同步机制，不仅可以避免死锁，而且性能更好。</li>
<li>在Java中可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作。存在的问题：<ul>
<li><strong>ABA</strong>问题 如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化。那么解决该问题的方法是使用版本号，每次变量更新的时候把版本号加1。JDK提供了一个类AtomicStampedReference来解决ABA问题。</li>
<li>循环时间开销大。</li>
<li>只能保证一个共享变量的原子操作。</li>
</ul>
</li>
</ul>
<h3 id="CAS-Compare-and-swap"><a href="#CAS-Compare-and-swap" class="headerlink" title="CAS(Compare-and-swap)"></a>CAS(Compare-and-swap)</h3><p>In <a href="https://www.wikiwand.com/en/Computer_science" target="_blank" rel="noopener">computer science</a>, <strong>compare-and-swap</strong> (<strong>CAS</strong>) is an <a href="https://www.wikiwand.com/en/Atomic_(computer_science" target="_blank" rel="noopener">atomic</a>) <a href="https://www.wikiwand.com/en/Instruction_(computer_science" target="_blank" rel="noopener">instruction</a>) used in <a href="https://www.wikiwand.com/en/Thread_(computer_science" target="_blank" rel="noopener">multithreading</a>#Multithreading) to achieve <a href="https://www.wikiwand.com/en/Synchronization_(computer_science" target="_blank" rel="noopener">synchronization</a>). It compares the contents of a memory location with a given value and, only if they are the same, modifies the contents of that memory location to a new given value.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span><span class="params">(<span class="keyword">int</span>* reg, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ATOMIC();</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *reg;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval)</span><br><span class="line">     *reg = newval;</span><br><span class="line">  END_ATOMIC();</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CAS比较与交换的伪代码可以表示为：</p>
<p>do{<br>​       备份旧数据；<br>​       基于旧数据构造新数据；<br>}while(!CAS( 内存地址，备份的旧数据，新数据 ))  </p>
<p><img src="http://p6sh0jwf6.bkt.clouddn.com/2018-04-17-160954.jpg" alt="191145387966044"></p>
<p>（上图的解释：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p>
<p>就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的 commit-retry 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p>
<h3 id="CAS的问题："><a href="#CAS的问题：" class="headerlink" title="CAS的问题："></a>CAS的问题：</h3><p>Some CAS-based algorithms are affected by and must handle the problem of a <a href="https://www.wikiwand.com/en/Type_I_error#False_negative_vs._false_positive" target="_blank" rel="noopener">false positive</a> match, or the <a href="https://www.wikiwand.com/en/ABA_problem" target="_blank" rel="noopener">ABA problem</a>. It is possible that between the time the old value is read and the time CAS is attempted, some other processors or threads change the memory location two or more times such that it acquires a bit pattern which matches the old value. </p>
<p>解决的方式一般都是多设置一个计数器或者说设置一个版本号。</p>
<h1 id="线程封闭-1"><a href="#线程封闭-1" class="headerlink" title="线程封闭"></a><strong>线程封闭</strong></h1><ul>
<li>仅在单线程内访问数据，不共享数据。</li>
<li>栈封闭是线程封闭的一种特例，局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。</li>
<li>维持线程封闭性的一种更规范方法是使用<strong>ThreadLocal</strong>, 这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本， 因此get总是返回由当前执行线程在调用set时设置的最新值。<ul>
<li>当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。</li>
<li>从概念上来讲，可以将<code>ThreadLocal&lt;T&gt;</code>视为包含了<code>Map&lt;Thread,T&gt;</code>对象，其中保存了特定于该线程的值。</li>
<li>ThreadLocalRandom是线程本地变量，每个生成随机数的线程都有一个不同的生成器。但都在同一个类中被管理，对于程序员来说时透明的。</li>
<li>相比于使用共享的Random对象为所有线程生成随机数，这种机制具有更好的性能。</li>
</ul>
</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul>
<li>可以理解为用HashMap存储数据，Key是Thread，Value是数据。</li>
<li>通过重写<code>initialValue</code>方法来定义初始值。</li>
<li>可以用于线程上下文带来的参数传递。</li>
</ul>
<h1 id="并发数据结构"><a href="#并发数据结构" class="headerlink" title="并发数据结构"></a>并发数据结构</h1><h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p>Java提供了一些可以用于并发程序中的数据结合，分阻塞式和非阻塞式的。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap也是基于散列的Map，但它使用了不同的加锁策略来提供更高的并发性和伸缩性。采用了一种粒度更细的加锁机制来实现更大程度的共享，称为分段锁。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>在迭代期间不需要对容器进行加锁或复制。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。</p>
<p>仅当迭代操作远远多于修改操作时，才应该使用写入时复制。</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>BlockingQueue简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。</p>
<p>一种最常见的生产者-消费者设计模式就是线程池与工作队列的组合，在Executor任务执行框架中就体现这种模式。</p>
<ul>
<li>LinkedBlockingQueue</li>
<li>ArrayBlockingQueue</li>
<li>SynchronousQueue</li>
<li>Deque</li>
<li>ConcurrentLinkedDeque</li>
<li>LinkedBlockingDeque</li>
<li>PriorityBlockingQueue</li>
<li>DelayQueue</li>
<li>ConcurrentSkipListMap</li>
</ul>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>我们希望多个线程之间能够相互之间交换信息，从而能够更好的协作，完成任务。线程之间通过wait notify方法进行通信。同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流，阻塞队列可以作为同步工具类，其他类型的同步工具类包括<strong>信号量</strong>、<strong>栅栏</strong>、以及<strong>闭锁</strong>。</p>
<p>线程之间的通信机制有两种：共享内存和消息传递。</p>
<ul>
<li>共享内存，线程之间共享程序的公共状态，通过写-读内存中的公共状态来隐式通信。</li>
<li>消息传递，线程之间必须通过发送消息来显式通信。</li>
</ul>
<h3 id="Interrupt-wait-notify"><a href="#Interrupt-wait-notify" class="headerlink" title="Interrupt wait notify"></a>Interrupt wait notify</h3><ul>
<li>Thread提供了<strong>interrupt</strong>方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状态。</li>
<li>中断是一种协作机制。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作-<strong>前提是如果线程B愿意停止下来</strong>。</li>
<li>调用interrupt并不意味着立即停止目标线程正在进行的工作，而是传递了请求中断的消息。</li>
<li>由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。</li>
<li>所有的对象都会有一个wait set， 用来存放调用了该对象wait方法之后进入block状态线程。</li>
<li>线程从wait set中被唤醒顺序不一定是FIFO。</li>
<li>wait方法会释放锁对象，当被唤醒之后需要再去请求锁对象，得到锁对象之后，代码会从wait的地方开始往下执行。</li>
</ul>
<h3 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h3><p>闭锁是一种不同工具类，可以延迟线程的进度直到其到达终止状态。闭锁相当于一扇门，在闭锁到达结束状态之前，这扇门一直是关闭的。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。</p>
<ul>
<li><strong>CountDownLatch</strong><ul>
<li>CountDownLatch是一种灵活的闭锁实现，可以在上述各种情况使用，它可以是一个或多个线程等待一组事件发生。</li>
<li>这个类使用一个<strong>整数</strong>进行初始化，这个整数就是线程要等待完成的操作的数目。当一个线程要等待某些操作先执行完时，需要调用await()方法，这个方法让线程进入休眠直到等待的所有操作都完成，当某个操作完成后，它将调用countDown()方法将CountDownLatch类的内部计数器减1,，当计数器变为0的时候，CountDownLatch将唤醒所有调用await()方法而进入休眠的线程。</li>
<li>CountDownLatch类有三个基本元素：<ul>
<li>一个初始值，即定义必须等待的先行完成的操作的数目。</li>
<li>await()方法</li>
<li>countDown()方法，每个被等待的事件在完成的时候调用。</li>
</ul>
</li>
<li>CountDownLatch机制<ul>
<li>CountDownLatch机制不是用来保护共享资源或者临界区的，它是用来同步执行多个任务的一个或者多个线程；</li>
<li>CountDownLatch只准许进入一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Counting-Semaphore"><a href="#Counting-Semaphore" class="headerlink" title="Counting Semaphore"></a>Counting Semaphore</h3><p>计算信号量用来控制同时访问某个特定资源的操作数量，或者执行某个指定操作的数量。</p>
<p>Semaphore中管理着一组虚拟的许可，许可的初始数量可通过构造函数来指定，在执行操作时可以首先获得许可，并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可。release方法将返回一个许可给信号量。</p>
<p>Semaphore可以用来实现资源池。</p>
<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏和闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。</p>
<ul>
<li><strong>CyclicBarrier</strong><ul>
<li>CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集。</li>
<li>CyclicBarrier类使用一个整型数进行初始化，这个数是需要在某个点上同步的线程数。</li>
<li>当一个线程到达的指定的点后，它将调用await()方法等待其他的线程，当线程调用await()方法后，CyclicBarrier类将阻塞这个线程并使之休眠直到所有其他线程到达。当最后一个线程调用CyclicBarrier类的await()方法时，CyclicBarrier对象将唤醒所有在等待的线程，然后这些线程将继续执行。</li>
<li>CyclicBarrier类有一个很有意义的改进，即它可以传入另一个Runnable对象作为初始化参数。当所有的线程都到达集合点后，CyclicBarrier类将这个Runnable对象作为线程执行。</li>
</ul>
</li>
</ul>
<h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a><strong>Phaser</strong></h3><p>允许执行并发多阶段任务。当我们有并发任务并且需要分解成几步执行时，这种机制就非常适用。Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才允许执行下一步。</p>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger允许在并发任务之间交换数据。Exchanger类允许在两个线程之间定义同步点，当两个线程都到达同步点时，它们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，同时第二个线程的数据结构进入到第一个线程中。</p>
<h2 id="并发编程框架"><a href="#并发编程框架" class="headerlink" title="并发编程框架"></a>并发编程框架</h2><h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><p>任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。串行执行的问题在于其糟糕的响应性和吞吐量，而“为每个任务分配一个线程”的问题在于资源管理的复杂性。</p>
<p>通过使用Executor，可以实现各种調优、管理、监视、记录日志、错误报告和其他功能，如果不使用任务执行框架，那么要增加这些功能非常困难。</p>
<p>当运行大量的并发任务，手动创建Runnable对象和Thread对象来执行它们有如下缺点:</p>
<ul>
<li>必须实现所有与Thread对象管理相关的代码，比如线程的创建、结束以及结果获取。</li>
</ul>
<p>执行器的另一个优势是Callable接口，这个接口的主方法名称为call()，可以返回结果。当发送一个Callable对象给执行器时，将获得一个实现了Future接口的对象，可以使用这个对象控制Callable对象的状态和结果。</p>
<p>执行器框架(Executor Framework)将任务的创建和执行进行了分离，通过这个框架，只需要实现Runnable接口的对象和使用Executor对象，然后将Runnable对象发送给执行器。执行器再负责运行这些任务所需要的线程，包括线程的创建，线程的管理以及线程的结束。</p>
<p>它提供了一种标准的方法将任务的提交过程与执行过程解偶开来，并用Runnable来表示任务。</p>
<p>Executor的实现还提供了生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。</p>
<p>Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。</p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><ul>
<li>为了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口，添加了一些用于生命管理的方法。</li>
<li>在ExecutorService关闭后提交的任务将由“拒绝执行处理器”来处理，它会抛弃任务，或者使得execute方法将转入终止状态。</li>
</ul>
<h3 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h3><ul>
<li>线程池，是指管理一组同构工作线程的资源池。</li>
<li>在线程池中执行任务比为每个任务分配一个线程优势更多，通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。</li>
<li>可以通过调用Executors中的静态工厂方法之一来创建一个线程池。</li>
<li>当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。<ul>
<li><strong>AbortPolicy</strong>：中止策略，是默认的饱和策略，该策略抛出未经检查的RejectedExecutionException。</li>
<li><strong>CallerRunsPolicy</strong>：调用者策略，实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li>
</ul>
</li>
<li>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时，都会调用这个方法。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">newFixedThreadPool</td>
<td style="text-align:center">创建一个固定长度的线程池；<br>在默认情况下将使用一个无界的LinkedBlockingQueue。</td>
</tr>
<tr>
<td style="text-align:center">newCachedThreadPool</td>
<td style="text-align:center">1. 创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。<br>2. 对于非常大的或者无界的线程池，可以通过使用SynchronousQueue来避免任务排队。<br>3. 只有当线程池是无界的或者可以拒绝任务时，SynchronousQueue才有实际价值。</td>
</tr>
<tr>
<td style="text-align:center">newSingleThreadExecutor</td>
<td style="text-align:center">1. 是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行。<br></td>
</tr>
<tr>
<td style="text-align:center">newScheduledThreadPool</td>
<td style="text-align:center">1. 创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br>2.为了在定时执行器中等待一段给定的时间后执行一个任务，需要使用schedule()方法。</td>
</tr>
<tr>
<td style="text-align:center">Customized ThreadPoolExecutor</td>
<td style="text-align:center">1. Java并发API提供了大量接口和类来实现并发应用程序，这些接口和类既包含底层机制，如Thread类，Runnable接口或Callable接口，synchronized关键字，也包含了高层机制，如Executor框架，尽管如此，开发应用中，仍会发现已有的Java类无法满足需求。<br>2. 步骤：<br>2.1 实现一个接口以拥有接口定义的功能，如 ThreadFactory接口。<br>2.2 覆盖类的一些方法，改变这些方法的行为，来满足需求，例如，覆盖Thread类的run()方法。<br>3. 任务：<br>3.1 通过Runnable接口实现的任务，不返回结果。<br>3.2 通过Callable接口实现的任务，它返回结果。</td>
</tr>
</tbody>
</table>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><ul>
<li>Callable这个接口声明了call()方法，可以在这个方法里实现任务的具体逻辑操作。Callable接口时一个泛型接口，这就意味着必须声明call()方法返回的数据类型。</li>
<li>Future这个接口声明了一些方法来获取由Callabel对象产生的结果，并管理它们的状态。</li>
</ul>
<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>工厂模式在面向对象编程中是一个应用广泛的设计模式，它是一种创建模式。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/14/Perceptron-Learning-Algorithm/" rel="next" title="Perceptron Learning Algorithm">
                <i class="fa fa-chevron-left"></i> Perceptron Learning Algorithm
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/17/Logistic-Regression/" rel="prev" title="Logistic Regression">
                Logistic Regression <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Conghuai Cai" />
            
              <p class="site-author-name" itemprop="name">Conghuai Cai</p>
              <p class="site-description motion-element" itemprop="description">Algorithm/Machine Learning/Deep Learning/NLP</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/conghuaicai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:caiconghuai@gmail.com" target="_blank" title="Email">
                      
                        <i class="fa fa-fw fa-envelope"></i>Email</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/6383237207/profile?topnav=1&wvr=6" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/caiconghuai" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#并发基础"><span class="nav-number">1.</span> <span class="nav-text">并发基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#三个重要概念"><span class="nav-number">1.1.</span> <span class="nav-text">三个重要概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全"><span class="nav-number">1.2.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无状态性"><span class="nav-number">1.2.1.</span> <span class="nav-text">无状态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#竞态条件"><span class="nav-number">1.2.2.</span> <span class="nav-text">竞态条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重要的概念"><span class="nav-number">2.</span> <span class="nav-text">重要的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread"><span class="nav-number">2.1.</span> <span class="nav-text">Thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runnable"><span class="nav-number">2.2.</span> <span class="nav-text">Runnable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile"><span class="nav-number">2.3.</span> <span class="nav-text">Volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wait-Set"><span class="nav-number">2.4.</span> <span class="nav-text">Wait Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future"><span class="nav-number">2.5.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写锁"><span class="nav-number">2.6.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变对象"><span class="nav-number">2.7.</span> <span class="nav-text">不可变对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程封闭"><span class="nav-number">2.8.</span> <span class="nav-text">线程封闭</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原子操作、原子变量"><span class="nav-number">3.</span> <span class="nav-text">原子操作、原子变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#同步锁"><span class="nav-number">3.1.</span> <span class="nav-text">同步锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock"><span class="nav-number">3.2.</span> <span class="nav-text">Lock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子变量"><span class="nav-number">3.3.</span> <span class="nav-text">原子变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-Compare-and-swap"><span class="nav-number">3.3.1.</span> <span class="nav-text">CAS(Compare-and-swap)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS的问题："><span class="nav-number">3.3.2.</span> <span class="nav-text">CAS的问题：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程封闭-1"><span class="nav-number">4.</span> <span class="nav-text">线程封闭</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">4.1.</span> <span class="nav-text">ThreadLocal</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发数据结构"><span class="nav-number">5.</span> <span class="nav-text">并发数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发集合"><span class="nav-number">5.1.</span> <span class="nav-text">并发集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">5.1.1.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">5.1.2.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">5.1.3.</span> <span class="nav-text">BlockingQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程通信"><span class="nav-number">5.2.</span> <span class="nav-text">线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Interrupt-wait-notify"><span class="nav-number">5.2.1.</span> <span class="nav-text">Interrupt wait notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Latch"><span class="nav-number">5.2.2.</span> <span class="nav-text">Latch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Counting-Semaphore"><span class="nav-number">5.2.3.</span> <span class="nav-text">Counting Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Barrier"><span class="nav-number">5.2.4.</span> <span class="nav-text">Barrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phaser"><span class="nav-number">5.2.5.</span> <span class="nav-text">Phaser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchanger"><span class="nav-number">5.2.6.</span> <span class="nav-text">Exchanger</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发编程框架"><span class="nav-number">5.3.</span> <span class="nav-text">并发编程框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor框架"><span class="nav-number">5.3.1.</span> <span class="nav-text">Executor框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExecutorService"><span class="nav-number">5.3.2.</span> <span class="nav-text">ExecutorService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPool"><span class="nav-number">5.3.3.</span> <span class="nav-text">ThreadPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable"><span class="nav-number">5.3.4.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadFactory"><span class="nav-number">5.3.5.</span> <span class="nav-text">ThreadFactory</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Conghuai Cai</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("gDGQAvMXvJB5uSIhpUvw90hy-gzGzoHsz", "36U43UE0rMrmve1e0J8NOBhA");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
